// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: filemetas.sql

package queries

import (
	"context"
)

const createFileMeta = `-- name: CreateFileMeta :exec
INSERT INTO filemetas (
    content_type,
    owner_type,
    owner_id,
    user_id,
    uri
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
`

type CreateFileMetaParams struct {
	ContentType string `json:"content_type"`
	OwnerType   string `json:"owner_type"`
	OwnerID     int    `json:"owner_id"`
	UserID      int    `json:"user_id"`
	Uri         string `json:"uri"`
}

func (q *Queries) CreateFileMeta(ctx context.Context, arg CreateFileMetaParams) error {
	_, err := q.db.Exec(ctx, createFileMeta,
		arg.ContentType,
		arg.OwnerType,
		arg.OwnerID,
		arg.UserID,
		arg.Uri,
	)
	return err
}

const deleteFileMetaByID = `-- name: DeleteFileMetaByID :exec
DELETE FROM filemetas
WHERE id = $1
`

func (q *Queries) DeleteFileMetaByID(ctx context.Context, id int) error {
	_, err := q.db.Exec(ctx, deleteFileMetaByID, id)
	return err
}

const deleteFileMetaByNoteID = `-- name: DeleteFileMetaByNoteID :exec
DELETE FROM filemetas
WHERE owner_type = $1 AND owner_id = $2
`

type DeleteFileMetaByNoteIDParams struct {
	OwnerType string `json:"owner_type"`
	OwnerID   int    `json:"owner_id"`
}

func (q *Queries) DeleteFileMetaByNoteID(ctx context.Context, arg DeleteFileMetaByNoteIDParams) error {
	_, err := q.db.Exec(ctx, deleteFileMetaByNoteID, arg.OwnerType, arg.OwnerID)
	return err
}

const fileMetasExistsByIDAndUserID = `-- name: FileMetasExistsByIDAndUserID :one
SELECT EXISTS(SELECT 1 FROM filemetas WHERE id = $1 AND user_id = $2)
`

type FileMetasExistsByIDAndUserIDParams struct {
	ID     int `json:"id"`
	UserID int `json:"user_id"`
}

func (q *Queries) FileMetasExistsByIDAndUserID(ctx context.Context, arg FileMetasExistsByIDAndUserIDParams) (bool, error) {
	row := q.db.QueryRow(ctx, fileMetasExistsByIDAndUserID, arg.ID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getFileMetaByID = `-- name: GetFileMetaByID :one
SELECT content_type, owner_type, owner_id, user_id,uri
FROM filemetas
WHERE id = $1
`

type GetFileMetaByIDRow struct {
	ContentType string `json:"content_type"`
	OwnerType   string `json:"owner_type"`
	OwnerID     int    `json:"owner_id"`
	UserID      int    `json:"user_id"`
	Uri         string `json:"uri"`
}

func (q *Queries) GetFileMetaByID(ctx context.Context, id int) (GetFileMetaByIDRow, error) {
	row := q.db.QueryRow(ctx, getFileMetaByID, id)
	var i GetFileMetaByIDRow
	err := row.Scan(
		&i.ContentType,
		&i.OwnerType,
		&i.OwnerID,
		&i.UserID,
		&i.Uri,
	)
	return i, err
}

const getFileMetaURI = `-- name: GetFileMetaURI :one
SELECT uri
FROM filemetas
WHERE id = $1
`

func (q *Queries) GetFileMetaURI(ctx context.Context, id int) (string, error) {
	row := q.db.QueryRow(ctx, getFileMetaURI, id)
	var uri string
	err := row.Scan(&uri)
	return uri, err
}

const getFileMetas = `-- name: GetFileMetas :many
SELECT id, content_type, owner_type, owner_id,user_id, uri
FROM filemetas
`

func (q *Queries) GetFileMetas(ctx context.Context) ([]Filemeta, error) {
	rows, err := q.db.Query(ctx, getFileMetas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Filemeta
	for rows.Next() {
		var i Filemeta
		if err := rows.Scan(
			&i.ID,
			&i.ContentType,
			&i.OwnerType,
			&i.OwnerID,
			&i.UserID,
			&i.Uri,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
